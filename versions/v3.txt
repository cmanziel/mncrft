/*
    * glBufferData inside while loop
*/

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include <list>
#include <vector>
#include "utils.h"
//#define STB_IMAGE_IMPLEMENTATION
//#include "stb_image.h"

float zTranslate = 0.0f;

unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str(); //c_str return pointer to first char in the string, just like &source[0]
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    int success;
    char infoLog[512];

    glGetShaderiv(id, GL_COMPILE_STATUS, &success);

    if (success == GL_FALSE) {
        glGetShaderInfoLog(id, 512, nullptr, infoLog);
        std::cout << "COMPILATION FAILED\n" << infoLog << std::endl;
    }

    return id;
}

// shader source code is literally a string of glsl code, normally you read it from a file
static unsigned int CreateProgram(const std::string& vsPath, const std::string& fsPath)
{
    unsigned int program = glCreateProgram(); //returns program id

    std::ifstream vsFile, fsFile;
    std::stringstream vsSourceStream, fsSourceStream; // can't directly copy the contents of the file into a string (can't do vsSource << vsFile.rdbuf());
    std::string vsSource, fsSource; // source code of shaders read from files of path vsPath and fsPath

    vsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    fsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    try
    {
        // open files
        vsFile.open(vsPath);
        fsFile.open(fsPath);
        // read file's buffer contents into streams
        vsSourceStream << vsFile.rdbuf();
        fsSourceStream << fsFile.rdbuf();
        // close file handlers
        vsFile.close();
        fsFile.close();
        // convert stream into string
        vsSource = vsSourceStream.str();
        fsSource = fsSourceStream.str();
    }
    catch (std::ifstream::failure& e)
    {
        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ: " << e.what() << std::endl;
    }

    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vsSource);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fsSource);

    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);

    int success;
    char infoLog[512];

    //glValidateProgram(program); used as an ulterior check of the execution of the program, used with glGetProgram (similar to glGetProgramiv ecc.)
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (success == GL_FALSE) {
        glGetProgramInfoLog(program, 512, nullptr, infoLog);
        std::cout << "LINKING FAILED\n" << infoLog << std::endl;
    }

    //can delete the shader because they're already attached to a program
    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}

static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (action == GLFW_PRESS) {
        if (key == GLFW_KEY_W)
            zTranslate += 0.2;
        else if (key == GLFW_KEY_S)
            zTranslate -= 0.2;
    }
}


int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(1280, 960, "DAISZIOPORCO", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    if (glewInit() != GLEW_OK)
    {
        std::cout << "error initializing GLEW" << std::endl;
        return -1;
    }

    float matArray[] = {
        1.0, 2.0, 3.0, 4.0,
        5.0, 6.0, 7.0, 8.0,
        9.0, 10.0, 11.0, 12.0,
        13.0, 14.0, 15.0, 16.0
    };

    Mat4 mat = Mat4(matArray);
    Mat4 mat2 = Mat4(nullptr);

    std::cout << mat.getElement(3, 2) << std::endl;

    // create shaders
    // array di vertici
    // muovi con input le coordinate dei vertici

    float vertices[] = {
        -0.5f, -0.5f, -0.5f,
        0.5f, -0.5f, -0.5f,
        0.5f, 0.5f, -0.5f,
        0.5f, 0.5f, -0.5f,
        -0.5f, 0.5f, -0.5f,
        -0.5f, -0.5f, -0.5f
    };

    std::vector<glm::vec3> verts = {
        glm::vec3(-0.5f, -0.5f, -0.5f),
        glm::vec3(0.5f, -0.5f, -0.5f),
        glm::vec3(0.5f, 0.5f, -0.5f),
        glm::vec3(0.5f, 0.5f, -0.5f),
        glm::vec3(-0.5f, 0.5f, -0.5f),
        glm::vec3(-0.5f, -0.5f, -0.5f)
    };

    unsigned int shaderProgram;

    glfwSetKeyCallback(window, key_callback);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);


        float blockHeight = 1.0;

        for (glm::vec3 vert : verts) {
            if (vert.y > 1.0) {
                verts.push_back(glm::vec3(vert.x, vert.y - 1.0, vert.z));
                verts.push_back(glm::vec3(vert.x, vert.y - 1.0 - blockHeight, vert.y));
            }
        }

        float vertices[verts.size() * 3];

        int j = 0;

        for (int i = 0; i < sizeof(verts) / sizeof(glm::vec3); i++) {
            vertices[j] = verts[i].x;
            vertices[j + 1] = verts[i].y;
            vertices[j + 2] = verts[i].z;

            j += 3;
        }

        unsigned int VBO;

        glGenBuffers(1, &VBO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

        shaderProgram = CreateProgram("shaders/shader.vs", "shaders/shader.fs");
        glUseProgram(shaderProgram);

        glDrawArrays(GL_TRIANGLES, 0, 6);

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glDeleteProgram(shaderProgram);
    glfwTerminate();
    return 0;
}