/*
    * snake-like movement using model matrix,
*/

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include <list>
#include "utils.h"
//#define STB_IMAGE_IMPLEMENTATION
//#include "stb_image.h"

float yTranslate = 0.0f;

unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str(); //c_str return pointer to first char in the string, just like &source[0]
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    int success;
    char infoLog[512];

    glGetShaderiv(id, GL_COMPILE_STATUS, &success);

    if (success == GL_FALSE) {
        glGetShaderInfoLog(id, 512, nullptr, infoLog);
        std::cout << "COMPILATION FAILED\n" << infoLog << std::endl;
    }

    return id;
}

// shader source code is literally a string of glsl code, normally you read it from a file
static unsigned int CreateProgram(const std::string& vsPath, const std::string& fsPath)
{
    unsigned int program = glCreateProgram(); //returns program id

    std::ifstream vsFile, fsFile;
    std::stringstream vsSourceStream, fsSourceStream; // can't directly copy the contents of the file into a string (can't do vsSource << vsFile.rdbuf());
    std::string vsSource, fsSource; // source code of shaders read from files of path vsPath and fsPath

    vsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    fsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    try
    {
        // open files
        vsFile.open(vsPath);
        fsFile.open(fsPath);
        // read file's buffer contents into streams
        vsSourceStream << vsFile.rdbuf();
        fsSourceStream << fsFile.rdbuf();
        // close file handlers
        vsFile.close();
        fsFile.close();
        // convert stream into string
        vsSource = vsSourceStream.str();
        fsSource = fsSourceStream.str();
    }
    catch (std::ifstream::failure& e)
    {
        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ: " << e.what() << std::endl;
    }

    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vsSource);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fsSource);

    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);

    int success;
    char infoLog[512];

    //glValidateProgram(program); used as an ulterior check of the execution of the program, used with glGetProgram (similar to glGetProgramiv ecc.)
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (success == GL_FALSE) {
        glGetProgramInfoLog(program, 512, nullptr, infoLog);
        std::cout << "LINKING FAILED\n" << infoLog << std::endl;
    }

    //can delete the shader because they're already attached to a program
    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}

static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (action == GLFW_PRESS) {
        if (key == GLFW_KEY_W)
            yTranslate += 0.2;
        else if (key == GLFW_KEY_S)
            yTranslate -= 0.2;
    }
}


int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(1280, 960, "DAISZIOPORCO", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    if (glewInit() != GLEW_OK)
    {
        std::cout << "error initializing GLEW" << std::endl;
        return -1;
    }

    float matArray[] = {
        1.0, 2.0, 3.0, 4.0,
        5.0, 6.0, 7.0, 8.0,
        9.0, 10.0, 11.0, 12.0,
        13.0, 14.0, 15.0, 16.0
    };

    Mat4 mat = Mat4(matArray);
    Mat4 mat2 = Mat4(nullptr);

    std::cout << mat.getElement(3, 2) << std::endl;

    // create shaders
    // array di vertici
    // muovi con input le coordinate dei vertici

    float vertices[] = {
        -0.5f, -0.5f, -0.5f,
        0.5f, -0.5f, -0.5f,
        0.5f, 0.5f, -0.5f,
        0.5f, 0.5f, -0.5f,
        -0.5f, 0.5f, -0.5f,
        -0.5f, -0.5f, -0.5f
    };

    glm::vec3 verts[] = {
        glm::vec3(-0.5f, 0.5f, -0.5f),
        glm::vec3(0.5f, -0.5f, -0.5f),
        glm::vec3(-0.5f, -0.5f, -0.5f),
        glm::vec3(-0.5f, -0.5f, -0.5f)
    };

    glm::vec3 cubePos[] = {
    glm::vec3(2.0f,  5.0f, 15.0f),
    glm::vec3(-1.5f, -2.2f, 2.5f),
    glm::vec3(-3.8f, -2.0f, 12.3f),
    glm::vec3(2.4f, -0.4f, 3.5f),
    glm::vec3(-1.7f,  3.0f, 7.5f),
    glm::vec3(1.3f, -2.0f, 2.5f),
    glm::vec3(1.5f,  2.0f, 2.5f),
    glm::vec3(1.5f,  0.2f, 1.5f),
    glm::vec3(1.3f,  1.0f, 1.5f), // behind camera
    glm::vec3(0.0f,  0.0f,  0.0f),
    glm::vec3(2.0f,  5.0f, -15.0f),
    glm::vec3(-1.5f, -2.2f, -2.5f),
    glm::vec3(-3.8f, -2.0f, -12.3f),
    glm::vec3(2.4f, -0.4f, -3.5f),
    glm::vec3(-1.7f,  3.0f, -7.5f),
    glm::vec3(1.3f, -2.0f, -2.5f),
    glm::vec3(1.5f,  2.0f, -2.5f),
    glm::vec3(1.5f,  0.2f, -1.5f),
    glm::vec3(-1.3f,  1.0f, -1.5f)
    };

    std::list<glm::vec3> cubePositions;

    cubePositions.push_back(glm::vec3(0.0, 0.0, 0.0)); // initial cube not translated

    unsigned int VBO;

    glGenBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);

    unsigned int shaderProgram = CreateProgram("shaders/shader.vs", "shaders/shader.fs");
    glUseProgram(shaderProgram);

    glfwSetKeyCallback(window, key_callback);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        glm::vec3 moveVec = glm::vec3(0.0, yTranslate, 0.0);

        //for (int i = 0; i < sizeof(verts) / sizeof(glm::vec3); i++) {
        //    if (verts[i].y + moveVec.y > 1.0) {
        //        cubePositions.push_back(glm::vec3(0.0, -(verts[i].y + moveVec.y + 1.0), 0.0));
        //    }
        //}

        int i = 0;
        int flag = 0;

        while ((i < sizeof(verts) / sizeof(glm::vec3)) && flag != 1) {
            float vertY = verts[i].y + moveVec.y;
            if (verts[i].y + moveVec.y > 1.0) {
                cubePositions.push_back(glm::vec3(0.0, -(1.0 + (verts[i].y - verts[i + 1].y + 0.2)), 0.0));
                flag = 1;
            }

            i++;
        }

        for (std::list<glm::vec3>::iterator it = cubePositions.begin(); it != cubePositions.end(); it++) {

            glm::mat4 model = glm::mat4(1.0f);

            glm::vec3 transVec = moveVec + *it;

            model = glm::translate(model, transVec);
            
            int location = glGetUniformLocation(shaderProgram, "model");
            glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(model));

            glDrawArrays(GL_TRIANGLES, 0, 6);
        }

        cubePositions.clear();

        cubePositions.push_back(glm::vec3(0.0, 0.0, 0.0));

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glDeleteProgram(shaderProgram);
    glfwTerminate();
    return 0;
}