/*
    * renderizzare 1 cubo con VBO
    * movimento con tastiera
    * using an std::vector as the buffer for the VBO instead of an array
*/

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include "utils.h"
//#define STB_IMAGE_IMPLEMENTATION
//#include "stb_image.h"

float zTranslate = 0.0f;

unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str(); //c_str return pointer to first char in the string, just like &source[0]
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    int success;
    char infoLog[512];

    glGetShaderiv(id, GL_COMPILE_STATUS, &success);

    if (success == GL_FALSE) {
        glGetShaderInfoLog(id, 512, nullptr, infoLog);
        std::cout << "COMPILATION FAILED\n" << infoLog << std::endl;
    }

    return id;
}

// shader source code is literally a string of glsl code, normally you read it from a file
static unsigned int CreateProgram(const std::string& vsPath, const std::string& fsPath)
{
    unsigned int program = glCreateProgram(); //returns program id

    std::ifstream vsFile, fsFile;
    std::stringstream vsSourceStream, fsSourceStream; // can't directly copy the contents of the file into a string (can't do vsSource << vsFile.rdbuf());
    std::string vsSource, fsSource; // source code of shaders read from files of path vsPath and fsPath

    vsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    fsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    try
    {
        // open files
        vsFile.open(vsPath);
        fsFile.open(fsPath);
        // read file's buffer contents into streams
        vsSourceStream << vsFile.rdbuf();
        fsSourceStream << fsFile.rdbuf();
        // close file handlers
        vsFile.close();
        fsFile.close();
        // convert stream into string
        vsSource = vsSourceStream.str();
        fsSource = fsSourceStream.str();
    }
    catch (std::ifstream::failure& e)
    {
        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ: " << e.what() << std::endl;
    }

    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vsSource);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fsSource);

    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);

    int success;
    char infoLog[512];

    //glValidateProgram(program); used as an ulterior check of the execution of the program, used with glGetProgram (similar to glGetProgramiv ecc.)
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (success == GL_FALSE) {
        glGetProgramInfoLog(program, 512, nullptr, infoLog);
        std::cout << "LINKING FAILED\n" << infoLog << std::endl;
    }

    //can delete the shader because they're already attached to a program
    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}

static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (action == GLFW_PRESS) {
        if (key == GLFW_KEY_W)
            zTranslate += 0.2;
        else if (key == GLFW_KEY_S)
            zTranslate -= 0.2;
    }
}


int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(1280, 960, "DAISZIOPORCO", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    if (glewInit() != GLEW_OK)
    {
        std::cout << "error initializing GLEW" << std::endl;
        return -1;
    }

    float matArray[] = {
        1.0, 2.0, 3.0, 4.0,
        5.0, 6.0, 7.0, 8.0,
        9.0, 10.0, 11.0, 12.0,
        13.0, 14.0, 15.0, 16.0
    };

    Mat4 mat = Mat4(matArray);
    Mat4 mat2 = Mat4(nullptr);

    std::cout << mat.getElement(3, 2) << std::endl;

    // create shaders
    // array di vertici
    // muovi con input le coordinate dei vertici

    std::vector<float> vertices {
        -0.5f, -0.5f, -0.5f,
        0.5f, -0.5f, -0.5f,
        0.5f, 0.5f, -0.5f,
        0.5f, 0.5f, -0.5f,
        -0.5f, 0.5f, -0.5f,
        -0.5f, -0.5f, -0.5f
    };

    unsigned int VBO;

    glGenBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float), &vertices[0], GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

    unsigned int shaderProgram = CreateProgram("shaders/shader.vs", "shaders/shader.fs");
    glUseProgram(shaderProgram);

    glfwSetKeyCallback(window, key_callback);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        glm::mat4 model = glm::mat4(1.0f);

        model = glm::translate(model, glm::vec3(0.0, zTranslate, 0.0));

        glm::vec3 moveVec(0.0, zTranslate, 0.0);

        // set uniform with model matrix
        int location = glGetUniformLocation(shaderProgram, "moveVec");
        glUniform3fv(location, 1, glm::value_ptr(moveVec));

        glDrawArrays(GL_TRIANGLES, 0, 6);

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glDeleteProgram(shaderProgram);
    glfwTerminate();
    return 0;
}