/*
    * glBufferData inside while loop
*/

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <iostream>
#include <fstream>
#include <sstream>
#include <list>
#include <vector>
#include "utils.h"
//#define STB_IMAGE_IMPLEMENTATION
//#include "stb_image.h"

float zTranslate = 0.0f;

unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str(); //c_str return pointer to first char in the string, just like &source[0]
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    int success;
    char infoLog[512];

    glGetShaderiv(id, GL_COMPILE_STATUS, &success);

    if (success == GL_FALSE) {
        glGetShaderInfoLog(id, 512, nullptr, infoLog);
        std::cout << "COMPILATION FAILED\n" << infoLog << std::endl;
    }

    return id;
}

// shader source code is literally a string of glsl code, normally you read it from a file
static unsigned int CreateProgram(const std::string& vsPath, const std::string& fsPath)
{
    unsigned int program = glCreateProgram(); //returns program id

    std::ifstream vsFile, fsFile;
    std::stringstream vsSourceStream, fsSourceStream; // can't directly copy the contents of the file into a string (can't do vsSource << vsFile.rdbuf());
    std::string vsSource, fsSource; // source code of shaders read from files of path vsPath and fsPath

    vsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
    fsFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

    try
    {
        // open files
        vsFile.open(vsPath);
        fsFile.open(fsPath);
        // read file's buffer contents into streams
        vsSourceStream << vsFile.rdbuf();
        fsSourceStream << fsFile.rdbuf();
        // close file handlers
        vsFile.close();
        fsFile.close();
        // convert stream into string
        vsSource = vsSourceStream.str();
        fsSource = fsSourceStream.str();
    }
    catch (std::ifstream::failure& e)
    {
        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ: " << e.what() << std::endl;
    }

    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vsSource);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fsSource);

    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);

    int success;
    char infoLog[512];

    //glValidateProgram(program); used as an ulterior check of the execution of the program, used with glGetProgram (similar to glGetProgramiv ecc.)
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (success == GL_FALSE) {
        glGetProgramInfoLog(program, 512, nullptr, infoLog);
        std::cout << "LINKING FAILED\n" << infoLog << std::endl;
    }

    //can delete the shader because they're already attached to a program
    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}

static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (action == GLFW_PRESS) {
        if (key == GLFW_KEY_W)
            zTranslate += 0.2;
        else if (key == GLFW_KEY_S)
            zTranslate -= 0.2;
    }
}


int main(void)
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(1280, 960, "DAISZIOPORCO", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    if (glewInit() != GLEW_OK)
    {
        std::cout << "error initializing GLEW" << std::endl;
        return -1;
    }

    float matArray[] = {
        1.0, 2.0, 3.0, 4.0,
        5.0, 6.0, 7.0, 8.0,
        9.0, 10.0, 11.0, 12.0,
        13.0, 14.0, 15.0, 16.0
    };

    Mat4 mat = Mat4(matArray);
    Mat4 mat2 = Mat4(nullptr);

    std::cout << mat.getElement(3, 2) << std::endl;

    // create shaders
    // array di vertici
    // muovi con input le coordinate dei vertici

    std::vector<glm::vec3> verts = {
        glm::vec3(-0.5f, -0.5f, -0.5f),
        glm::vec3(0.5f, -0.5f, -0.5f),
        glm::vec3(0.5f, 0.5f, -0.5f),
        glm::vec3(0.5f, 0.5f, -0.5f),
        glm::vec3(-0.5f, 0.5f, -0.5f),
        glm::vec3(-0.5f, -0.5f, -0.5f)
    };

    unsigned int shaderProgram;

    glfwSetKeyCallback(window, key_callback);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        glm::vec3 moveVec = glm::vec3(0.0, zTranslate, 0.0);

        float blockHeight = 1.0;

        int i = 0;
        int size = verts.size();
        int flag = 0;

        // add vertices to be rendered to the verts vector
        while (i < size && flag == 0) {
            glm::vec3 vert = verts[i];
            if (vert.y > 1.0) {
                // iterate through verts vector and translate every vertex by 1.0 to obtain the other cube vertices, then use push_back to add to the vector

                glm::mat4 translate(1.0);
                translate = glm::translate(translate, glm::vec3(0.0, -1.0, 0.0));

                for (glm::vec3 v : verts) {
                    glm::vec3 newVert = glm::vec4(v, 1.0) * translate; // new vertex to add to verts vector after translation
                    verts.push_back(newVert);
                }
                
                flag = 1;
            }

            i++;
        }

        std::vector<float> vertices;

        int j = 0;

        // fill the vertices vector with each vertex coming from the verts vector. the vertices vector is used for glBufferData
        for (glm::vec3 vert : verts) {
            vertices.push_back(vert.x);
            vertices.push_back(vert.y);
            vertices.push_back(vert.z);
        }

        unsigned int VBO;

        glGenBuffers(1, &VBO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(float), &vertices[0], GL_STATIC_DRAW);

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

        shaderProgram = CreateProgram("shaders/shader.vs", "shaders/shader.fs");
        glUseProgram(shaderProgram);

        int location = glGetUniformLocation(shaderProgram, "moveVec");
        glUniform3fv(location, 1, glm::value_ptr(moveVec));

        glDrawArrays(GL_TRIANGLES, 0, vertices.size() / 3);

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glDeleteProgram(shaderProgram);
    glfwTerminate();
    return 0;
}